# js基础-day-04



# 函数

* 为什么要？高效开发；

* 假设 我们要输出一个故事：

```javascript
console.log("从前有座山，山里有座庙");
console.log("庙里有个老和尚在给小和尚讲故事");
console.log("讲的是什么呢？");
console.log("老和尚对小和尚说：");
```



* 如果我想**随时随地的给别人讲**，代码就会很多；不友好；

```javascript
// 1次
console.log("从前有座山，山里有座庙");
console.log("庙里有个在给小和尚讲故事");
console.log("讲的是什么呢？");
console.log("老和尚对小和尚说：");


// 2次
console.log("从前有座山，山里有座庙");

// ......
```



## 介绍

* 函数：我们**把一段相对独立的具有特定功能的代码块封装起来**，形成一个**独立实体**，起个名字（函数名），在后续开发中可以**随时调用**。
* 作用：**封装（包起来）一段代码，可以随时拿来调用。**

![1598010241139](assets/1598010241139.png)



## 语法

```js
// function 关键字 用于声明函数
// tellStroy 函数名
function tellStroy() {
  // 里面叫函数体：我们封装，我们想随时随地拿来使用的东西；
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log("老和尚对小和尚说：");
}
```

* 调用：声明的函数，一段代码被包起来；需要被调用，才能执行当前的函数；

```js
tellStroy(); // 此时在控制台中就会输出一个故事

// 如果想输出多次，就可以调用多次这个函数
tellStroy(); 
tellStroy(); 
tellStroy(); 
```

* 注意：起名字重名，会覆盖；和变量一样；



## 参数

### 配置参数

* 参数：对于**函数**来说，函数**内部**的变量；
* 作用：为什么？给别人讲故事，不同的情况套用不同的人名；把函数封装的代码；
  * 不用去修改原来函数。
  * 通过参数可以控制函数的功能；
* 定义参数：位置，小括号上自定的参数；
* 特点：只能在内部使用，和外部没有关系；
* 使用：调用函数的时候，传入值，把值赋值给了形参；
* 语法：

```javascript
// 在小括号内的变量，对于函数来说，就是参数；
// 参数就是函数 内部的变量；
function 函数名(参数){
  // 函数体
}

// 参数：对于函数，这些参数都是形式上的参数，它就是代替位置，相当于是变量在这占了个坑；至于这个参数真实背后代表什么值，我们现在还不知道，具体要看调用的时候，传入什么数据；相当于是个模板！
function tellStroy(name){
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个老和尚在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log("老和尚对"+ name +"说：");
}
```

* 参数既然是**变量**，调用函数时传递一个值；

```javascript
// 调用函数的时候，传入参数；
tellStroy('清风');
tellStroy('明月');
```

* 需求：如果我们想在调用函数的时候，把老和尚的名字也明确一下，就把老和尚的名字作为变量改变下；

```javascript
// 声明函数，配置参数；
function tellStroy(name1,name2){
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个老和尚在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log(name1 "对"+ name2 +"说：");
}

// 调用函数
tellStroy('圆通','清风');
```





### 参数不赋值

* 变量：函数内部的变量，没有赋值，默认为undefined；和我们的变量一模一样；


```js
function tellStroy(name){
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个老和尚在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log("老和尚对"+ name +"说：");   // 老和尚对undefined说；
}
```

* 解决：对参数进行判断，如果是undefined，给一个默认值；

```js
function tellStroy(name){
    
  // if 条件语句
  if(name==undefined) {
      name = '小和尚'
  }
  else {
      name = name;
  }
  
  // 三元表达式；
  name = name?name:"小和尚"；
  console.log("从前有座山，山里有座庙");
  console.log("庙里有个老和尚在给小和尚讲故事");
  console.log("讲的是什么呢？");
  console.log("老和尚对"+ name +"说：");
}
```



### 形参与实参

* 形参：形式上的参数，函数内部的变量；
* 实参：调用函数时，真实参与运算的数据；
  * 把真实数据 实参数据 复制赋值了一份给形参；
* 相互不影响：传入简单值类型，互不影响；

```js
  // 特点（规则）：形参与实参相互不影响；
  // 形参：外面不能使用；和外面没有任何关系;只能函数内部使用；
  // 实参：把实参的数据，赋值(复制)了一份给形参；

  function fn(a) {
    a = a + 10;
  }

  var a = 10;
  fn(a);
  // a = a;
  // 前面a:形参，只能在函数内部使用，和外面没有关系；
  // 后面a:实参，外面的实参把自己的值，赋值（复制）了给里面的形参a；
```

* 如果在函数上配置上了形参，那么调用函数的时候就要相应的传入实参！



## 返回值

* 作用：函数内部运算出来的结果和外面没有任何；如果外面想用内部运算完的结果，设置返回值；
* 语法：

```js
  function fn(a) {
    a = a + 10;
    // 内部：只能在函数内部使用，把变量后面真实数据返回出去;
    // 关键字：return；
    return a;
  }

  // 外面：需要找个变量接受
  var b = fn(10);
  console.log(b);
```

* 特点规则：
  1. 作用：函数返回值，把内部的值进行返回，返回到外面；
  2. 执行：只要函数内部出现了return，函数内return下面的代码(函数内)不再执行；
  3. 返回:
     1. 有return， 后面有数据，返回数据；
     2. 有return 后面没有任何数据（变量）,默认返回undefined；
     3. 无return，函数就没有返回值，执行函数，默认返回undefined；

​      



## 案例：封装函数，调用返回1-n的和

* 步骤：
  * 1.把实际过程写出来。1-10；
  * 2.试着封装函数：
  * 3.是否配置参数？是否设置返回值？

```js
  function getSum(m) {
    var sum = 0;
    for (var i = 1; i <= m; i++) {
      sum += i;
    }
    return sum;
  }
```

* 函数的说明：（了解，抒写规范）

```js
// 经验：以后大家会经常看别人写的函数，用法；
/**
 * 函数的作用 - 求n-m之间的整数和
 * @param {type:number} n 较小值
 * @param {type:number} m 较大值
 * @returns {type:number} 整数和
 */
```

* 封装函数：调用的时候，返回 传入半径，返回圆的面积 ； 3.14 * r * r





## 案例：输出时间格式 2020-08-23 12:18:39

- 在js中，要获取系统的当前日期和时间，需要用到一个js自带的**Date对象** ，
- **现在先不用管什么是对象，先学习如何使用，对象能给我们带来什么作用**

```js
// 创建Date对象
var date = new Date();  // 里面有很多功能!

// 获取时间对象的各个部分，对象.方法();
// 获取年份
var year = date.getFullYear();
console.log(year);

// 获取月份,得到的月份是从0开始的 ，使用 0-11 表示 1-12 月
var month = date.getMonth();
console.log(month);

// 获取天
var day = date.getDate();
console.log(day);

// 获取小时
var hour = date.getHours();
console.log(hour);

// 获取分钟
var minute = date.getMinutes();
console.log(minute);

// 获取秒数
var second = date.1();
console.log(second);
```

- 为了格式上的好看：单位数，补位成双位数；

```js
if(day < 10){
    day = '0' + day;
}
```

* 那么这个过程就可以封装为函数；

```
function patchFrontZero(num) {
  if (num < 10) {
    num = "0" + num;
  }
  return num;
}
```

* 思考：返回指定格式时间功能其他地方也要用，怎么办？



## arguments

* 解决：多个参数的问题；

* 目标：无论输入多少个参数，都可以参加运算；
* 语法：arguments，获取所有实参的伪数组，**函数内部的变量（不是我们声明的，也不需要我们声明）**

```javascript
function fn(){
  console.log(arguments);
}
fn(1); // 输出 [1]
fn(1,2) // 输出 [1,2]
fn(1,2,3,4,5) // 输出 [1,2,3,4,5]
```

* arguments 这个东西看起来**样子像数组**，但是其实不是一个数组，我们管它叫 `伪数组`。它具有数组的长度和顺序等特征。本质为对象，
* arguments 伪数组可以**循环遍历**；

```javascript
function getSum(){
  var sum = 0;
  for(var i = 0; i < arguments.length ; i++){
    sum += arguments[i];
  }
  return sum;
}

getSum(1,2,3);// 输出 6
getSum(1,2,3,4,5); // 输出15
```

* 应用场景：**当我们不知道我们的参数个数的时候；**







## 函数表达式

* js中声明函数的方式不只有一种，还有一种方式叫`函数表达式`；
* 声明变量，赋值为函数；

```js
// 
var 函数名 = function (参数){
   //函数体
}

var getSum = function(a,b){
  return a + b;
}
getSum(10,20);
```

## 匿名函数(了解)

* 匿名函数：没有名字的函数，**但是**在js的语法中，是不允许匿名函数单独存在的，要配合其它语法使用：


```javascript
function (参数){
  函数体
}

var fn = function(a,b){
  return a + b;
};
```

* 自调用函数（自执行函数）：匿名函数的另外一种使用方法；很多时候，我们需要加载页面后，自动执行一个函数；

```js
// 定义之后，立刻调用，输出10
(function(){  
  console.log(10);  
})();
```



# 作用域

* 作用域：声明函数，变量作用范围，能生效的范围；
* 为什么要学作用域？
  * 函数：里面和外面；
  * **目前，我们要分清楚自己的声明的变量在哪个作用域下，也就是生效的范围是多大；**
  * **配合下面预解析的知识，经常是面试比较常问的基础题**；
* 全局：
  * 全局作用域：**全局的变量，能在JS部分的任何位置都可以访问；**
  * 全局变量：在全局作用域下声明的变量；
* 局部：
  * 局部作用域：只能在局部的作用域范围进行访问；
  * 局部变量：在局部作用域下声明的变量；

```js
//-----------------------------全局
var a = 10;
function f1(){
  console.log(a);
}


f1();// 变量a在函数外定义，可以在函数内使用


//-----------------------------局部
function f2(){
  var b = 20;
}
f2();
// 变量b在函数内定义，在函数外无法访问，报错： b is not defined
console.log(b); 


function f2(b){
}
f2(20);
// 变量b在函数内定义，在函数外无法访问，报错： b is not defined
console.log(b); 
```

* 局部变量的寻找 **规则**：
  * 先在当前自己的作用域的中找有没有**声明的变量**或者**函数名**，
  * 如果没有，往上层作用域找，
  * 如果上层作用域也没有，那么继续往上层找，
  * 直到报错；

```js
var a = 10;

function fn(b){
  console.log(b);
  console.log(a);
}

fn(20);  // 20 10
```





# 预解析

* JS代码 不是一下在浏览器内执行，需要浏览器对JS代码进行 预解析（过程）：
* 大白话：浏览器里面有一个人，先把JS代码读一遍，一行一行读；在内存上执行；
* **预解析（规则）：代码每次执行时进入新的作用域，声明的： var 变量、function 函数（){}，全部提升到当前作用域的最顶端；**
  * 进入新的作用域；全局和局部的顶端；
  * **提升：var 变量  function 函数（){}；**
  * 注意：预解析不是在执行代码(可以理解为在分析代码)，预解完成后才执行代码；
  * 了解：从概念的字面意义上说，“变量提升”意味着**变量和函数的声明**会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

* 全局作用域预解析前：

```javascript
console.log(a);
fn();


var a = 1;
function fn(){
  console.log("我是封装的函数"); 
}
```

* 全局作用域预解析后：

```js
var a;
function fn(){
  console.log("我是封装的函数"); 
}
// -----------------------------------------------顶端分界线

console.log(a);
fn();
a = 1;
```





* 局部 作用域预解析前：

```js
  // 局部作用域：函数内部
  function fn() {
    console.log(a);
    var a = 1;
  }

  fn();
```

* 局部 作用域预解析后：

```js
function fn() {
    var a;
    // -----------------------------------------------顶端分界线
    console.log(a);
    a = 1;
}

fn();
```





* 全局作用域  函数声明方式不同的预解析前：

```js
f1();
f2();

function f1(){
  console.log(1);
}
var f2 = function(){
  console.log(2);
}
```

* 全局作用域  函数声明方式不同的预解析后：

```javascript
function f1(){
  console.log(1);
}
var f2;
// -----------------------------------------------顶端分界线

f1();
f2();  // 报错：在调用f2的时候，f2还是undefined，就会报错
f2 = function(){
  console.log(2);
}
```





* 面试基础题：观察下面的代码，说出执行结果（预解析前）

```js
var num = 10;
fun();
console.log(num);


function fun() {
  console.log(num);
  var num = 20;
}
```

* 预解析后：

```js
// 预解析：先把你声明变量、函数先全部提升到你当前的作用域的最顶端；
var num;

function fun() {
    var num;
    console.log(num);
    num = 20;
}

// ------------------------------------------------------------假装的顶端分界线

// 赋值；
num = 10;
// 函数调用；
fun(); // 输出 undefined；
```





* 作业：观察下面的代码，说出执行结果（预解析前）【要熟悉 两条规则！！先！】

```js
var num = 10;
fun();
console.log(num);


function fun() {
  console.log(num);
  num = 20;
}
```






